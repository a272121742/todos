2014年06月27日 致胡老师的一封信
==========================

时至今日，在Meteor中的研究已经将近半年，对之前给定目标未能今早完成，实属抱歉。在独自摸索过程中，有为自己创造性的发现而欣喜过；有为能力的局限性而无奈过；有为复杂的问题困扰过；有为目标的实现纠结过。有时觉得自己独自拿了一块烫手的山芋，丢也丢不开，还必须一口口的吃掉。在这样艰苦的旅程中，我始终坚信我能做到，而且一直努力去做。每一个周末，我都在公司兢兢业业的度过，每一个夜晚，我都在思索明天研究的方向。但是成果未出，这是硬道理，但我殚精竭力，也尤为困难。现在我将我先前研究的结果做一个总结，期望在后续的研发过程中获得一些指导和力量。

##  Meteor结构框架

### 引言

先前我做了`DE-Grid`，这是一个组件，一个封装底层的视图组件。这个组件非常的不错，连我自己都为此而兴奋不已。但是当我从这样一个组件跳转到另一个组件（SchemaNestable）的时候，我发现问题就已经来了。Grid的架构是很不错的，但是SchemaNestable却依然要重新制定一种架构，这是一种可耻的重复行为，更可耻的是SchemaNestable的很多构建方式同Grid一样。这不得不让我思考，如何将这样的架构能够提炼出来。

### Meteor的组件底层

关于这一块，详情可以查阅以下几篇文档。

0.  [DE-Grid结构说明](https://github.com/a272121742/DE-Grid/blob/master/README.md)
0.  [模板vsJS](https://github.com/a272121742/DE-Grid/blob/master/模板vsJS.md)

在《结构说明》中，已经很明确了这样一种架构思想，但当时这种架构只是适用于Grid这种组件的。而《模板vsJS》却是这种架构思想的底层基础和依据，通过他，可以跳转将组件的架构思想提升为全局的架构思想。

通俗的来说，全局Application也是一个组件，只是他没有UI，或许也没有逻辑，但他提供了其中所有组件的运行、使用模型。因此，我花了一些时间去理解Meteor组件的由来。

### Application诞生

在经过仔细思考和实践之后，这样的一个逻辑框架终于被我提炼出来——[Application](https://github.com/a272121742/Application)。这个框架现阶段还在继续完善，有很多新增的功能在此Github上也没有完全上传。以下来讲一讲他的架构原理。

####  Java碰撞Extjs

因为之前都是做过Java和Extjs项目的，所以对这两种技术的架构也比较清楚。要做一件未知的事情，就要去用已知的内容去理解、消化、吸收。Java和Extjs都有类似的Application的概念，Java是将整个服务端作为一个Application，而Extjs是将整个客户端作为一个Application。Application作为一个全局的事物，一个特殊的容器，能够为其子容器提供很多特性，正如`迪米特法则`一样。有了Application之后，我就考虑，我们虽然是单页应用，但仍然有很多的独立页内容，这些内容通过路由来进行分发显示。每一个路由页面应该是相互独立，但都应该有自己的独立作用域。我把每一个独立的路由页面做成了Container，这样Application框架元素就有两个东西组成，一个Appliance，一个Container。

####  Meteor组件论

有了Application的框架模型，我们需要将他的是实现同Meteor的底层结合在一起。通过之前对他底层的了解，这是一件漫长的事，但得出来的结论相当令人惊喜。Meteor在0.8之后的版本中，所有的视图都将采用组件化。无论是模板Template，还是全局的GlobalHelper，亦或是模板的Helper，都会根一个东西产生交集——`UI.Component`。经过验证，视图中所有的元素，都会被转换为UI.Component的实现方式。在Extjs中，他就是将所有的视图组件化，从而构建的这样一个庞大而简单的框架。有了这样一个理论基础，我们的Application就可以开始添加骨架和灵魂。我通过继承和拓展UI.Component实现了Appliance和Container，并且将其应用在测试项目中，得到了与DE-Grid同样的效果。并且还具备之前不曾具备的特性。

####  Appliance组件

Applicance是一个组件，他的会是一个UI.Component的一个实现。他不仅提供了全局的作用域Application，还能够辅助Container进行跨容器的操作。他在整个应用中是唯一的，这与单应用的理解将是契合的。

####  Container组件

Container也是一个组件，他提供了容器上下文Context或者Scope。他可以获取Appliance组件，从而进行跨容器的操作。他在整个应用中不是唯一的，但必须嵌套在Appliance中。

####  效果

单是听这些理论，不足以见他的优势。但我可以描述他的效果和优势。

0.  非容器组件都有一个容器组件，从而获取上下文，并且不容容器提供的上下文是隔离的。
0.  非容器组件不用去寻找操作的数据，而直接从上下文获取或更新，并且这些都是时实的。
0.  如果一个容器组件需要操作其他容器，可以通过容器组件找到Appliance组件，然后由他找到其他容器进行数据更新。
0.  在不改变当前作用域的情况下（with-global-helper会改变当前作用域），模板的任何阶段都能获取所在容器的作用域（任督二脉被打通）。

有了这样的结构性框架之后，今后再开发组件，开发速度就会迅捷不少。如果增加常用的页面间的业务逻辑，无需在小的地方动刀动枪，而只需在架构上进行统一修订即可。

##  动态Collection

### 引言

这个工作是在某些环节进行收尾的时候才发现有这样一个问题。整个应用分为Server端和Client端，Collection也分为系统固有和动态产生的。做这样的工作是再一次页面刷新时发生的，所以不得不去解决这个问题。

### 需求

我们的需求是Client能够发出指令，让后台去生成Collection。生成的Collection又能去配置Schema和Validation，以保证数据的安全性和完备性。首先我们不考虑生成Collection之后是否生成视图，如果一个Schema或者Validation发生变化后， Client是否会与Server表现为一致性。

### 问题

事实上，一开始并不是这样的。我们可以从一个中间状态去描述这个问题。Meteor程序启动之后，会去进行init操作。init会去读取数据库，然后生成配置，客户端根据配置就能生成视图和数据。

首先是谁去读取数据库，当然是系统Collection去读取。读取到的配置就包含有新的Collection配置，然后我们生成动态Collection。这些都是Server会去进行的，Client是不会这样进行的，因为客户端能实现的程序操作是在整个客户端init完毕之后才能使用的。而且更为恶心的是，当客户端刷新之后，动态的内容全部都还原了。

所以我们必须想办法去保留动态Collection。我发先，当Client第一次请求Server的时候，Server是会发生init过程的，而且当客户端init完毕之后，客户端才能得到响应，才会去执行init操作。init执行完毕，Server将数据副本传输到Client端。如果Client重新加载，只是init再次发生，不影响Server端口的init发生。

### 解决方案

Client断init的时候，向Server端发出请求。服务端还是像之前的一样加载动态Collection，但加载完之后，将加载项回传给客户端，这样客户端就知道有哪些是动态Collection。Client端同Server一样，重新加载一次动态Collection即可。这样就保证了Client和Server的Collection一致性和完备性。

##  辅助插件

### 引言

工欲善其事，必先利其器。在研究的过程中，总会有一些或多或少的一些小问题发生，这些问题如果放任不解决，虽然不影响后面的研究工作，但是总让人感觉不舒服。所以，我有时会将能够抽离出来的功能再进行封装。

### console-global-helper

有的时候，我希望能查看模板中的某些数据，这是一件相当困难的事情。模板是HTML的，即便可以嵌入`<script>`标签，但是也无法得到helper或者data的值。这时候，我就需要一个能打印模板数据的工具了。因此，我做了一个[console-global-helper工具包](https://github.com/a272121742/console-global-helper)。其很多功能都类似JS中的`console`，这里没必要多说，使用方法都在文档中。

他的打印风格与其他的打印风格还是不一样的，所以更方便我们进行调试和检测。

### switch-global-helper

这是一个很简单的语言自然语法，但是Meteor就是没有提供。如果在代码中大面积的使用嵌套`if...else`，那代码也是相当恶心且不具备良好的可读性的。所以我觉得`switch`还是非常有必要的。目前这个包有一些问题没有完善，所以没有放到Github中，即便没有完善却任然可以使用，只是作为个人意愿希望他能做的更好。使用方法很简单，就是这样：

```javascript
{{#switch arg}}
  {{#case 1}}
    <!--如果arg等于1，渲染里面的内容-->
  {{/case}}
  {{case 2}}
    <!--如果arg等于2，渲染里面的内容-->
  {{/case}}
  {{case 3}}
    <!--如果arg等于3，渲染里面的内容-->
  {{/case}}
{{/switch}}
```

而且他不同于原先的自然语法，取消掉了break，使得至多只会有一行是会被渲染（执行）的。

我希望完善的内容是通过`console-global-helper`发现的，我发现`with`可以改变作用域，而其他的helper都不具备改变作用域的特性。我希望`switch`也具备改变作用域的特性。但是`with`一旦改变了作用域，就无法再使用之前作用域的数据，新的Meteor不提供向上查找的功能。我在试图寻早，如何改变作用域之后，还能向上找回原来的作用域。

### iterate-global-helper

对于有限的集合，我们能通过`each`进行遍历，而且仅限于数组。如果是map集合或者自定义集合甚至是树形结构，`each`就显得无能为力了。在研发的过程中，我试图在页面展示一颗树，发现这是无比艰难的事，我们能只能在后台把这种视图结构（JS代码）渲染完成之后再让客户端渲染。如此很是让我恶心。于是我决定把这个复杂的功能简单化。目前是实现了，但是没有提炼和封装，所以比较难看，同样没有在Github上发布。

对于tree，我们可以抽象为是有限个节点（node）构成的。树就是只有一个节点的对象，能否遍历取决于是否有子节点，同样子节点能否遍历取决于是否存在子子节点。这样问题就很容易抽象，这就是递归算法。递归和迭代还是有区别的，目前我把树的递归算法和集合的迭代算法都看作是一个算法，后面会思考如何去迭代map集合。

### tree-list-util

通过对象重构，做的一个tree和list相互转换的工具类。tree是一种非线性结构，而list是一种线性结构，MongoDB数据库两种都可以存储，但非线性结构不利于管理和维护。除了视图上展示的tree是非线性的，其他的我希望都能保证线性。当前这个工具内置在SchemaNestable中，还有待完善的地方，同样没有发布到Github中。


##  Schema、Validation

这一块将是一个大难点。因为逻辑的处理都相对比较容易，难的就是交互上和界面上。

对于Schema结构，他更像是一个JSON，因此我们需要一个简单的JSON编辑器，但又不同于JSON编辑器。常规的JSON编辑器，指定的是`key:value`，key是属性名，value是属性值。而我们需要的则不同，value则更应该表达一种类型。

由于JSON是可以扩展的，而Schema在扩展时需要有限制，例如基础类型是无法扩展的，数组只能扩展一次，对象可以任意扩展。所以我设计他的交互方式应该更像一个`nestable`，他在原有的JSON编辑器的操作上更具备灵活和适用。目前nestable会有一些bug，这种bug不仅是在Client端，在Server端返回到Client端之后，客户端也没办法用很好的交互方式去做响应，往往需要重新刷新页面去处理。显然这种方式是不可被接受的，但目前没有比这更好的方法，解决前端的痛点越来越深。

另外，我希望Schema是线性的、粒度化的，这样方便我将每一个Schema引入到Validation流程中。Validation主要针对每一个Schema去做额外的验证配置，因为每一个Schema都被确定了唯一类型，所以我明确知道基础数据类型结构是可以流向Validation去做配置管理的。Validation做验证配置也是在选型确定的情况下才去做的，而且Validation是很容易实现的。目前我们将采用`simple-schema`去做Validation模块的配置，但遇到一个很大的问题。`simple-schema`提供了复合类型（[String]、[Number]、[object]等）的验证，与我之前思考的单一类型验证有相互冲突的地方，导致程序运行频发异常。

##  问题

以上，就是现在全部研究出来的总结。相对来说，投入的力度和经历都很大了。但问题总是伴随着而来的，以上的逻辑都是没什么问题，问题就是反应在`交互`上的。

界面，就是交互的表达方式之一，如果涉及到数据的处理流程，这对于一个后端开发人员来说没有问题。但前端交互的加入，伴随着的将是付出惨重的代价。因为数据最终的结果只有一种，而交互的方式有多样，一些不确定因素和内在变因使得其中的思考难以琢磨。

##  计划

研发的过程，这是一种探索和产出的过程，如果内力不够，就无法想的到位、输出准确。因此业余我也会去构思如何去提升自己内力。我向朋友咨询如何将研发流程和团队管理当作是产品进行设计、包装，朋友告诉我，哪些是你的痛点，哪些就是应该解决的问题。对我来说，最大的痛点就是资源太少。

当我遇到一个技术难点的时候，我只能自己攻克，而没办法去像同道人士交流。做NodeJS开发的人并不多，做Meteor的甚少，而且对其中的理解也不是很深刻。我在网上组建了交流群，加入的人数少，几乎没有人是拿Meteor真正做过项目的，都是学习交流阶段。我有想法把Meteor的社区扩大，让更多的人参与进来，以便成为我们今后的技术资源。我也希望能够建立自己的团队，完善研发的流程。这不仅是一个愿景，更是在计划中的事。

##  分析现状

参加杭州JS大会，今年的感受会比往年淡了不少。一方面是据说，Nodejs0.12版本将会迎来重大更新，其中就是解决异步的问题，据传闻是将改用同步的方式执行异步。另一方面是ECMA6将于2015年发布，很多互联网行业似乎都在观望和等待。今年大会上，重中之重都是前端方面，而且已经开始大面积公开招人。记得第一届，虽说是JS大会，但主办方也是希望通过js这个名词能让更多人了解Nodejs，所以第一届的大会Nodejs占比50%。到了第二届，Nodejs已经逐渐被业界认知，而且北京技术发展雄厚， Nodejs内容占比很高，几乎达到80%，一些优秀的Nodejs框架和技术也在此被公开。但是本届大会，全场听完，大部分已经都是讲前端的，并且演讲台上公开招前端。确实，今年Nodejs发展平平，前端市场虽然没有新的突破，但前端依然是那么紧缺性的。其实说到底，我们缺少的也是这一块。

另外，今年我跟主办方申请，明年将有机会成为大会的speaker，分享我在Meteor上的点点滴滴。

##  咨询

后面我有很多计划要实现，例如整理文档，把之前写的很多都提交到Github上，再例如扩张Meteor技术圈子，以及管理团队、明确研发流程等。但是现阶段的事情还是得一步一步的走下去，目前遇到的问题，前面都讲了很多，希望胡老师能够给我们后面的进程提供一些技术支持和指导方向，谢谢！



































































































